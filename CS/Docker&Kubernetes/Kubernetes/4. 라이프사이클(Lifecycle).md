# 4. 라이프사이클(Lifecycle)

## 롤링 업데이트(Rolling Updates) & 롤백(Rollbacks)

+ deployment는 rollout을 트리거하고, 새 rollout은 새 deployment revision을 생성함

+ deployment 생성 후 수정한 경우(ex. 도커 업데이트, ...) → 새로운 revision이 생김

+ 이러한 revision들로 인해 변경을 추적 가능함 + 문제 발생 시, 이전 revision으로 rollback할 수 있음

+ Deployment 업데이트 방식 2가지

  1. yaml 파일 수정 + `kubectl apply -f [yaml 파일명].yaml` → 새로운 rollout 생성 or `kubectl edit deployment [deploy명]`
  2. 명령어로 업데이트 → ex) `kubectl set image deployment/myapp-deploymtn nginx=nginx:1.9.1` → 업데이트는 되지만, deployment를 정의한 파일은 수정되지 않음

+ Deployment 배포 종류

  ### Recreate

  + 기존 pod를 전부 내리고, 새로운 pod를 올림 → 새로운 pod가 뜨기 전까지 서비스가 불가능함

  + yaml 파일

    ```yaml
    #deployment-definition.yaml
    ...
    spec:
    	strategy:
    		type: Recreate
    ...
    ```

  ### 롤링 업데이트(RollingUpdate)

  + pod를 하나씩 내리고 올림 → 서비스 중단 없음

  + 동작방식

    1. 새로운 deployment 생성 → 그에 따른 replicaset 생성됨
    2. deployment 수정 → 이에 맞는 새로운 replicaset이 생성됨
    3. 이전 replicaset에서 pod를 1개씩 내리며 새로운 replicaset에서 pod를 하나씩 생성하며 교체함

    <img src="https://user-images.githubusercontent.com/33214969/161425832-b73502bd-7696-44ba-ae07-2254b950561f.png" alt="라이프사이클 - Recreate&RollingUpdate.png" width="50%;" />

  + yaml 파일

    ```yaml
    #deployment-definition.yaml
    ...
    spec:
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxUnavailable: 25%    # 업데이트 중 사용할 수 없는 최대 pod 개수 지정
          maxSurge: 25%    # 의도한 pod 수에 대해 생성할 수 있는 최대 pod 개수 지정
    ...
    ```

### 롤백(Rollback)

+ 새로운 deployment에 문제가 있어서 이전 revision으로 되돌리고 싶은 경우 롤백을 사용함
+ 관련 명령어
  + 롤아웃 조회 : `kubectl rollout status deploy [deploy명]`
  + 롤아웃 히스토리 정보 조회 : `kubectl rollout history deploy [deploy명]`
  + 롤백 : `kubectl rollback undo deploy [deploy명]`

<br/>

## Commands & Arguments

+ 컨테이너를 시작하기 위한 command 정의

  + docker run command에 command를 append → 이미지에 정의된 default command를 override함

    + ex)

      ```docker
      # docker image
      FROM Ubuntu
      CMD sleep 5
      ```

      이때, `docker fun ubuntu sleep 10` 실행하면 → sleep 10으로 override됨

  + entrypoint : 시작 시, 실행되는 command. command로 넘어가는 default parameter

    + ex)

      ```docker
      # docker image
      FROM Ubuntu
      ENTRYPOINT ["sleep"]
      ```

  + default parameter 지정

    + ex)

      ```docker
      # docker image
      FROM Ubuntu
      ENTRYPOINT ["sleep"]
      CMD ["5"]
      ```

      entrypoint를 변경 → (sleep2.0 10 실행) `docker run --entrypoint slepp2.0 ubuntu-sleeper 10`

    + yaml 파일

      ```yaml
      # pod-definition.yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: ubuntu-sleeper-pod
      spec:
        containers:
          - name: ubuntu-sleeper
            image: ubuntu-sleeper
            command: ["sleep2.0"]    # (docker) endtrypoint
            args: ["10"]             # (docker) cmd
      ```

      ```yaml
      # pod-definition.yaml
      apiVersion: v1
      kind: Pod
      metadata:
        name: ubuntu-sleeper-pod
      spec:
        containers:
          - name: ubuntu-sleeper
            image: ubuntu-sleeper
            command:
              - "sleep"    # (docker) endtrypoint
              - "10"
      ```

<br/>

## 환경변수(Environment Variables)

+ 쿠버네티스 환경 변수는 ymal 파일 or 다른 리소스로 전달함

### Env Variables

+ 환경 변수를 정의함 - name, value로 구성된 배열 형식

+ yaml 파일

  ```yaml
  # pod-definition.yaml
  ...
  spec:
    containers:
    ...
      env:
      - name: APP_COLOR
        value: pink
  ...
  ```

  = `docker run -e APP_COLOR=pink simple-webapp-color`

### ConfigMaps

+ 설정 데이터를 key-value 형태로 저장 - valueFrom 형식

+ ConfigMap 생성 후 pod에 주힙하는 방식으로 사용됨

+ yaml 파일

  ```yaml
  # pod-definition.yaml
  ...
  spec:
    containers:
    ...
      env:
      - name: APP_COLOR
      - valueFrom:
          configMapKeyRef: app-config    # configmap파일의 metadata.name 컬럼
  ...
  ```

  ```yaml
  # config-map.yaml
  appVersion: v1
  kind: ConfigMap
  metadata:
    name: app-config
  data:
    APP_COLOR: pink
    APP_MODE: prod
  ```

+ yaml 파일에 configmap 추가 방법 3가지

  1. Env

     ```yaml
     envFrom:
     - configMapRef:
         name: app-config
     ```

  2. Simgle Env

     ```yaml
     env:
       - name: app-config
         valueFrom:
           configMapRef:
             name: app-config
             key: APP_COLOR
     ```

  3. Volume

     ```yaml
     volumes:
       - name: app-config-volume
         configMap:
           name: app-config
     ```

+ 관련 명령어

  + configmap 조회 : `kubectl get configmaps`
  + configmap 파일 생성 - Imperative(명령적) : `kubectl create configmap \\ [config명] --from-literal=[key]=[value]`
  + configmap 파일 생성 - Declarative(선언적) : `kubectl create -f \\ [config명] --from-file=[환경변수 파일명].properties`

### Secrets

+ password or key와 같이 민감한 정보를 저장하기 위한 ojbect

+ ConfigMap과 비슷하지만 encode or hash된 형태로 저장됨

+ yaml 파일

  ```yaml
  # pod-definition.yaml
  ...
  spec:
    containers:
    ...
      env:
      - name: APP_COLOR
        valueFrom:
          secretKeyRef: app-secret    # secret파일의 metadata.name 컬럼
  ...
  ```

  ```yaml
  # secret-data.yaml
  appVersion: v1
  kind: Secret
  metadata:
    name: app-secret
  data:
    DB_Host: bXlzcWn=        # -> DB_Host: mysql
    DB_User: cm9vdA==        # -> DB_User: root
    DB_Password: cGFzd3JK    # -> DB_Password: paswrd
    # manifest 파일로 생성할 경우, encode된 형태로 저장해야 함
  ```

+ yaml 파일에 secret 추가 방법 3가지

  1. Env

     ```yaml
     envFrom:
     - secretRef:
         name: app-config
     ```

  2. Simgle Env

     ```yaml
     env:
       - name: DB_Password
         valueFrom:
           secretRef:
             name: app-secret
             key: DB_Password
     ```

  3. Volume

     ```yaml
     volumes:
       - name: app-secret-volume
         secret:
           name: app-secret
     ```

+ secret 타입

  + Opaque : 기본값<br/> - `kubectl create secret generic \\\\ [secret명] --from-literal=[key]=[value]`<br/> - `kubectl create secret generic \\\\ [secret명] --from-file=[파일명].properties`
  + docker secret<br/> - `kubectl create secret docker-registry dockersecret --docker-username= --docker-password= --docker-email= --docker-service=https://~`
  + [kubernetes.io/tls](http://kubernetes.io/tls) : TLS 인증서 저장<br/> - `kubectl create secret tls [secretAUD] --key tls.key --cert tls.crt`
  + [kubernetes.io/service-account-token](http://kubernetes.io/service-account-token) : 쿠버네티스 인증토큰 저장
  + [kubernetes.io/dockerconfigjson](http://kubernetes.io/dockerconfigjson) : 도커 저장소 인증정보 저장
  + [kubernetes.io/dockercfg](http://kubernetes.io/dockercfg) : 직렬화 된(serialized) ~/.dockercfg 파일
  + [kubernetes.io/basic-auth](http://kubernetes.io/basic-auth) : 기본 인증을 위한 자격 증명(credential)
  + [kubernetes.io/ssh-auth](http://kubernetes.io/ssh-auth) : SSH를 위한 자격 증명

+ 관련 명령어

  + secret 조회 : `kubectl get secrets`
  + secret 상세 조회 : `kubectl describe secrets [secret명]` / (yaml 파일 조회) `kubectl get secret [secret명] -o yaml`
  + configmap 파일 생성 - Imperative(명령적) : `kubectl create secret generic \\ [secret명] --from-literal=[key]=[value]` / `kubectl create secret generic \\ [secret명] --from-file=[파일명].properties`
  + configmap 파일 생성 - Declarative(선언적) : `kubectl create -f [secret 파일명].yaml`
  + 데이터 encode(base64) : `echo -n 'mysql' | base64` (결과) bXlzcWn=
  + 데이터 decode(base64) : `echo -n 'bXlzvWn=' | base64 --decode` (결과) mysql
  + (컨테이너 안에서) volume의 secret 값 확인 : `ls /opt/app-secret-volumes` (결과) DB_Host DB_Password DB_User / `cat /opt/app-secret-volumes/DB_Password` (결과) paswrd

<br/><br/>

롤링 업데이트 & 롤백<br/>[참고] https://nopanderer.github.io/kubernetes/2021-07-28-lifecycle/<br/>[참고] https://kdeon.tistory.com/66?category=911987

Commands & Arguments<br/>[참고] https://nopanderer.github.io/kubernetes/2021-07-28-lifecycle/<br/>[참고] https://kdeon.tistory.com/66?category=911987