# 2-3. 스케줄링(Scheduling)

## 자원 사용량(Resource Requirement) & Limits

+ 각 pod마다 실행을 위해 리소스 자원이 필요함(ex. cpu, memory, ...) → 스케줄러가 이를 고려하여 pod를 노드에 스케줄링 함
+ 모든 노드가 해당 pod의 리소스를 수용할 수 없으면, 해당 pod는 Pending 상태가 됨

### 리소스 요청(Resource Requests)

```tex
▫️ pod or 컨테이너에 필요한 최소한의 리소스 양을 요청할 수 있음
```

+ 설정된 만큼의 자원의 여유가 있는 노드가 있어야 pod를 해당 노드에서 실행 & 스케줄링 가능함

+ 만약 여유 자원이 없다면 Pending 상태로 실행됨 + 클러스터 안에 여유가 생길 때까지 대기함

+ 각 pod의 default : cpu = 0.5 / memory = 256Mi → yaml 파일에서 수정 가능함

+ yaml 파일

  ```yaml
  #pod-definition.yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: simple-webapp-color
    labels:
      name: simple-webapp-color
  spec:
    containers:
    - name: simple-webapp-color
      image: simpe-webapp-color
      ports:
        - containerPort: 8080
      resources:
        requests:    # Resource Request 설정
          memory: "1Gi"
          cpu: 1
  ```

### 리소스 제한(Resource Limits)

```tex
▫️ pod or 컨테이너에 사용할 수 있는 최대한의 리소스 양을 제한함
```

+ requests가 설정되어 있다면 그 리소스와 같거나 더 커야함

+ `OOMKilled(Out Of Memory)` 에러를 예방할 수 있음

+ 도커에서는 컨테이너에 리소스 제한이 없음 + 쿠버네티스에서는 컨테이너마다 default로 1 vCPU, 512Mi로 제한함

+ cpu를 오버해서 사용하면 → 쓰로틀링을 걸어서 limit 이상 사용할 수 없음

+ 메모리는 limit를 오버할 수 있음 → 단, 계속 오버되면 해당 pod는 종료됨

+ namespace에 `LimitRange` 오브젝트를 만들어서 디볼트로 지정할 Limit과 request를 셋팅할 수 있음

+ yaml 파일

  ```yaml
  #pod-definition.yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: simple-webapp-color
    labels:
      name: simple-webapp-color
  spec:
    containers:
    - name: simple-webapp-color
      image: simpe-webapp-color
      ports:
        - containerPort: 8080
      resources:
        requests:
          memory: "1Gi"
          cpu: 1
        limits:    # Resource Limit 설정
          memory: "2Gi"
            cpu: 2
  ```

### 리소스 사용량(Resource Requirement)

+ CPU - 본인이 사용할 수 있는 자원의 코어 개수로 표시

  + 각 pod의 default : cpu = 0.5
  + cpu의 최소 : 0.1(=100m) or 1m

  + 0.1 = cpu 코어 하나의 10%만큼만 할당

  + cpu 1 = 1 vCPU (= 스레드 1개)

+ Memory - 바이트 단위로 측정

  + 각 pod의 default : memory = 256Mi
  + memory 단위

<br/>

## 데몬셋(DaemonSets)

```tex
▫️ 각 노드에 1개의 pod만 배치하는 역할
```

<img src="https://user-images.githubusercontent.com/33214969/161425037-c0709162-474f-461a-9353-99cceb2115a1.png" alt="스케줄링 - 데몬셋.png" width="70%;" />

+ 각 노드에 pod를 1개씩 배치하고 싶을 때 사용함

+ 모든 노드에 pod가 1개씩 동작함을 보장함 → 노드 추가/삭제와 무관함

+ 모든 모니터링 or 로그 수집기 등의 목적에 적합한 오브젝트임

+ ex) kube proxy, 네트워크 에이전트(weavenet, calico, ...), ...

+ 동작과정

  + 버전 12부터는 node affinity와 defaul scheduler를 통해 각 pod를 노드에 할당함

+ yaml 파일

  ```yaml
  #daemon-set-definition.yaml
  apiVersion: apps/v1
  kind: DaemonSet
  metadata:
    name: monitoring-daemon
  spec:
    selector:
      matchLabels:
        app: monitoring-agent
    template:
      metadata:
        labels:
          app: monitoring-agent
        spec:
          containers:
          - name: monitoring-agent
            image: monitorint-agent
  ```

+ 관련 명령어

  + DaemonSet 조회 : `kubectl get daemonsets` / `kubectl get ds`
  + DaemonSet 상세 조회 : `kubectl describe daemonsets [daemonset명]`
  + DaemonSet 생성 : `kubectl create -f [yaml 파일명].yaml`

<br/><br/>

[참고] https://nopanderer.github.io/kubernetes/2021-07-25-scheduling/<br/>[참고] https://velog.io/@seunghyeon/Kubernetes-5.-파드-스케줄링<br/>[참고] https://freedeveloper.tistory.com/409?category=877486<br/>[참고] https://skasha.tistory.com/92?category=798024<br/>