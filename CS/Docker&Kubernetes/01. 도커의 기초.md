### 도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문<br/>

현장에서 바로 활용할 수 있는 컨테이너 개발 기법과 실전 기술<br/>by. 야미다 아키노리 지음 / 심효섭 옮김<br/>

# Chapter 01. 도커의 기초

### 01. 도커란 무엇인가

```tex
▫️ 컨테이너형 가상화 기술을 구현하기 위한 상주 애플리케이션 + 이 애플리케이션을 조작하기 위한 명령행 도구로 구성되는 프로덕트(product)
```

+ 특징

  + 애플리케이션 배포에 특화되어 있음 → 애플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있음
  + 몇 줄짜리 구성 파일과 명령어 한 줄로 애플리케이션 or 미들웨어가 이미 갖춰진 테스트용 가상환경(도커 컨테이너)을 빠르게 구축할 수 있음
  + 오버헤드가 적어짐
  + 개발 환경 구축뿐만 아니라 개발 후 운영 환경에 대한 배포 or 애플리케이션 플랫폼으로 기능할 수 있음 → 기존 가상 머신보다 뛰어남
  + 이식성이 뛰어남 → 로컬 머신의 도커 환경에서 실행하던 컨테이너를 다른 서버에 있는 도커 환경에 배포 or 그 반대로도 가능함
  + 컨테이너 간 연동이 가능함
  + 클라우드 플랫폼을 지원함
  + 컨테이너를 쉽게 만들고 사용하고 버릴 수 있음
  + Dockerfile 코드를 기반으로 복제 및 배포가 이루어짐 → 재현성이 높음
  + 환경의 영향을 덜 받고 배포가 간편함

+ 도커가 적합하지 않은 경우

  + 좀 더 엄밀한 리눅스 계열 운영 체제의 동작이 요구되는 가상 환경을 구축해야 하는 경우
  + FreeBSD 같은 비리눅스 환경이 필요한 경우

+ 도커의 기본 개념

  + 도커 → 애플리케이션 배포에 특화됨 + 컨테이너 활용에 유리한 생태계가 잘 갖춰짐

  + 도커 컨테이너(Container)

    ```tex
    ▫️ 가상 운영 체제 → 운영 체제(인프라)와 애플리케이션을 함께 담은 상자 같은 개념
    ```

  + 컨테이너형 가상화 기술 → 가상화 소프트웨어 없이도 운영 체제의 리소스를 격리해 가상 운영체제를 만듦

  + 호스트 운영 체제 가상화 → 운영 체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 애뮬레이션하는 방법. 게스트 운영 체제를 만드는 방식.

    + 컨테이너형 가상화 기술보다 구조적으로 오버헤드가 큼

    <img src="https://user-images.githubusercontent.com/33214969/148767603-9764c5fe-b8e9-48da-b2b8-1d0a47368e8c.jpeg" alt="IMG_08BA965B43A1-1.jpeg" width="50%;" />

  + 도커 vs LXC

    + 호스트 운영 체제의 영향을 받지 않는 실행 환경(Docker Engine을 이용한 실행 환경 표준화) → 도커는 컨테이너에 애플리케이션 실행 환경이 함께 배포되는 방식이라 운영 체제의 영향을 강하게 받지 않음
    + DSL(Dockerfile)을 이용한 컨테이너 구성 및 애플리케이션 배포 정의
    + 이미지 버전 관리
    + 레이어 구조를 갖는 이미지 포맷 → 차분 빌드가 가능함
    + 도커 레지스트리 → 이미지 저장 서버 역할을 함
    + 프로그램 가능한 다양한 기능의 API

    + 도커는 리눅스 커널에서 컨테이너를 구현하는 Linux namespaces or cgroups 등의 API를 직접 실행하는 "libcontainer" 라이브러리를 개발함

    <img src="https://user-images.githubusercontent.com/33214969/148767773-c95966a6-4957-46ca-a07b-6a62be6b7db5.jpeg" alt="IMG_392650F119AA-1.jpeg" width="50%;" />

+ 도커 스타일 체험하기

  1. 셀 스크립트 파일("helloworld") 생성 → 애플리케이션 역할

  2. 셀 스크립트와 같은 폴더에 Dockerfile 작성

     > + FROM절 : 컨테이너의 원형(틀) 역할을 할 도커 이미지(운영 체제)를 정의
     > + COPY절
     > + RUN절 : 도커 컨테이너 안에서 어떤 명령을 수행하기 위한 것
     > + CMD절 : 완성된 이미지를 도커 컨테이너로 실행하기 전에 먼저 실행할 명령을 정의

     

     <img src="https://user-images.githubusercontent.com/33214969/148768126-7f6d041e-8840-4edc-b361-962660632962.jpeg" alt="IMG_DFBEC8C4B1E6-1.jpeg" width="70%;" />

  3. 이 Dockerfile을 사용해 이미지 빌드 및 실행 → Dockfile이 있는 폴더에서 docker image build 명령 실행

     <img src="https://user-images.githubusercontent.com/33214969/148768236-6c9d65de-0792-45c5-a5e4-73ce7221c9cf.jpeg" alt="IMG_07AAAAB1430D-1.jpeg" width="50%;" />

  4. 도커 컨테이너를 실행 → 빌드가 끝난 후 docker container fun 명령 실행

     <img src="https://user-images.githubusercontent.com/33214969/148768317-b920ecc7-c6d1-421a-b237-13fbcd62e737.jpeg" alt="IMG_4CFAA3287A2C-1.jpeg" width="50%;" />

  + 도커 이미지 빌드

    ```tex
    ▫️ Dockerfile or 애플리케이션 실행 파일을 사용해서 도커 컨테이너의 원형이 될 이미지를 만드는 과정 (위의 2번 과정)
    ```

<br/>

### 02. 도커를 사용하는 의의

+ 도커를 사용하는 의의
  + 변화하지 않는 실행 환경으로 멱등성(Idempotency) 확보
  + 코드를 통한 실행 환경 구축 및 애플리케이션 구성
  + 실행 환경과 애플리케이션의 일체화로 이식성 향상
  + 시스템을 구성하는 애플리케이션 및 미들웨어의 관리 용이성

1. 환경 차이로 인한 문제 방지
   * 인프라의 가변성(mutable infrastructure) 허용 → 배포 대상 서버 간에 차이가 있어 애플리케이션이 기대했던 대로 동작하지 않음
     * 코드로 관리하는 인프라(Infastructure as Code) - 코드 기반으로 인프라를 정의한다는 개념<br/> → 서버를 어떻게 구성할 것인지, 어떤 라이브러리와 도구를 설치할지를 코드로 정의함<br/> → 셰프(Chef)나 앤서블(Ansible) 같은 프로비저닝 도구로 서버를 구축함<br/> → 수작업이 개입할 여지를 줄이고 코드 중심으로 바꿈 → 쉽게 같은 구성의 서버 여러 대를 복제할 수 있음
     * 불변 인프라(Immutable Ingrastructure) - 어떤 시점의 서버 상태를 저장해 복제할 수 있게 하자는 개념<br/> → 제대로 설정된 상태의 서버를 항상 사용할 수 있음<br/> → 서버에 변경을 가하고 싶은 경우<br/> → 새로운 서버 구축 > 그 상태를 이미지로 저장 > 그 이미지를 복제<br/>
        ** 멱등성 - 언제든 몇 번을 실행해 같은 결과가 보장됨<br/>
       ⇒ 도커는 인프라 구성이 Dockerfile로 관리됨 → 코드로 관리하는 인프라 + 기존 컨테이너를 빠르게 폐기 후 새로 구축 가능(불변 인프라)
     * 애플리케이션 & 인프라 묶어서 구축
       1. 인프라 관리 + 애플리케이션 배포
          * 도커 컨테이너 - 운영 체제(인프라)와 애플리케이션을 함께 담은 상자 같은 개념 → 도커 이미지 형태로 저장하고 재사용이 가능함
          * 도커 이미지 빌드 - 인프라와 애플리케이션을 함께 묶는 과정 → 그 경계가 없어진 만큼 작업 환경의 차이가 줄음
       2. 높은 이식성
          * 생성해 둔 도커 이미지는 도커가 설치된 머신이라면 어디서든 실행 가능함
          * 로컬 환경에서 도커를 실행할 수 있다면 서버에서 실행되는 도커 컨테이너를 개발자의 로컬 도커 환경에서도 똑같이 실행할 수 있음

2. 애플리케이션 구성 관리의 용이성

   * 일정 규모를 넘는 시스템은 주로 여러 개의 애플리케이션과 미들웨어를 조합하는 형태로 구성함 → 시스템 전체에 대한 적절한 구성 관리가 필요해짐

   * 많은 작업을 해야 하는 시스템(ex. 대규모 트래픽 처리) → 도커가 설치된 서버(도커 노드)를 여러 대 갖추고 + 이 노드 그룹에 필요한 만큼의 애플리케이션 컨테이너를 배포해야 함

     * 도커 컴포즈(Docker Compose)

       ```tex
       ▫️ 여러 컨테이너를 사용하는 애플리케이션을 쉽게 관리할 수 있는 도구
       ```

       * yaml 포맷으로 작성된 설정 파일로 컨테이너를 정의 or 컨테이너 간의 의존 관계를 정의 → 시작 순서를 제어함

     + 도커 스웜(Docker Swarm)

       ```tex
       ▫️ 도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐 있는 여러 컨테이너를 관리할 수 있도록 한 도구
       ```

       + 여러 컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리 도커 스웜은 컨테이너 증가/감소, 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 / 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있음
       + 배포 시에도 롤링 업데이트가 가능함 → 운영 면에서도 좋음
         + 롤링 업데이트 : 오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는 것)

     + 컨테이너 오케스트레이션(Container Orchestration)

       ```tex
       ▫️ 여러 서버에 걸쳐 있는 여러 컨테이너를 관리하는 기법
       ```

       + 컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리잡은 것이 쿠버네티스(Kubernetes)임

     + 쿠버네티스(Kubernetes)

       ```tex
       ▫️ 컨테이너 오케스트레이션 분야에서의 사실상 표준. 구글이 오랫동안 컨테이너를 운영하며 얻은 노하우를 담은 오픈 소스 소프트웨어
       ```

       + 도커 스웜보다 기능이 충실 + 확장성이 높음

     * 웹 애플리케이션 + Redis 컨테이너 구성 예시

<img src="https://user-images.githubusercontent.com/33214969/148770044-f4d13c12-a7e5-4228-9dd3-531f9f22b12a.jpeg" alt="IMG_0254E604BF95-1.jpeg" width="30%;" />

3. 운영 환경에서 및을 발하는 도커
   * 운영에 도움을 주기 위한 도구 : GCP → 쿠버네티스 기반의 구글 쿠버네티스 엔진(GKE), AWS → 아마존 엘라스틱 컨테이너 서비스(ECS), 애저 → 애저 컨테이너 서비스 등

4. 새로운 개발 스타일
   * 인프라와 애플리케이션이 모두 컨테이너로 형태로 제공되며 인프라와 애플리케이션의 설정을 모두 코드 수준에서 쉽게 수정 가능함<br/> → 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해짐